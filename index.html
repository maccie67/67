<!DOCTYPE html>
<html>
<head>
  <title>Hockey Game</title>
  <style>
    canvas { 
      border: 2px solid black; 
      background: #e0f7fa; 
      display: block; 
      margin: auto; 
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="400"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let keys = {};
let score = { red: 0, blue: 0 };

document.addEventListener("keydown", e => keys[e.code] = true);
document.addEventListener("keyup", e => keys[e.code] = false);

class Player {
  constructor(x, y, color, isAI=false, isGoalie=false, team="red") {
    this.x = x; this.y = y;
    this.color = color;
    this.radius = 10;
    this.speed = 2;
    this.isAI = isAI;
    this.isGoalie = isGoalie;
    this.team = team;
  }

  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
    ctx.fillStyle = this.color;
    ctx.fill();
    ctx.closePath();
  }

  moveAI() {
    if (!this.isAI) return;

    // --- Goalies follow puck side to side ---
    if (this.isGoalie) {
      let homeX = this.team === "red" ? netLeft.x + netLeft.width + this.radius : netRight.x - this.radius;
      let homeY = puck.y; // follow puck vertically

      this.x += (homeX - this.x) * 0.1;
      this.y += (homeY - this.y) * 0.1;

      // Keep inside crease
      if (this.team === "red") {
        this.x = Math.max(netLeft.x + netLeft.width, Math.min(netLeft.x + netLeft.width + 30, this.x));
      } else {
        this.x = Math.max(netRight.x - 30, Math.min(netRight.x, this.x));
      }
      this.y = Math.max(netLeft.y, Math.min(netLeft.y + netLeft.height, this.y));

      // Save puck if close
      let dx = puck.x - this.x, dy = puck.y - this.y;
      let dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < this.radius + puck.radius + 2 && puck.carriedBy === null) {
        puck.carriedBy = this;
        this.passToTeammate();
      }
      return;
    }

    // --- Regular AI for skaters ---
    if (puck.carriedBy && puck.carriedBy.team === this.team) {
      if (Math.random() < 0.01) this.shoot();
    } else {
      this.x += (puck.x - this.x) * 0.01;
      this.y += (puck.y - this.y) * 0.01;
    }
  }

  passToTeammate() {
    let teammates = (this.team === "red" ? team1 : team2).filter(p => !p.isGoalie);
    if (teammates.length > 0) {
      let mate = teammates[Math.floor(Math.random()*teammates.length)];
      puck.carriedBy = null;
      let dx = mate.x - this.x, dy = mate.y - this.y;
      let dist = Math.sqrt(dx*dx + dy*dy);
      puck.vx = dx/dist * 5;
      puck.vy = dy/dist * 5;
    }
  }

  shoot() {
    if (puck.carriedBy === this) {
      // ðŸš¨ No shooting from inside crease
      if (this.team === "red" && this.x > netRight.x - 40 && this.y > netRight.y && this.y < netRight.y + netRight.height) return;
      if (this.team === "blue" && this.x < netLeft.x + netLeft.width + 40 && this.y > netLeft.y && this.y < netLeft.y + netLeft.height) return;

      // Allowed shot
      puck.carriedBy = null;
      if (this.team === "red") {
        puck.vx = 6;
        puck.vy = (Math.random()-0.5)*4;
      } else {
        puck.vx = -6;
        puck.vy = (Math.random()-0.5)*4;
      }
    }
  }
}

class Puck {
  constructor(x,y) {
    this.x = x; this.y = y;
    this.radius = 5;
    this.vx = 0; this.vy = 0;
    this.carriedBy = null;
  }
  draw() {
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
    ctx.fillStyle="black";
    ctx.fill(); ctx.closePath();
  }
  update() {
    if (this.carriedBy) {
      this.x = this.carriedBy.x;
      this.y = this.carriedBy.y;
    } else {
      this.x += this.vx; this.y += this.vy;
      this.vx *= 0.98; this.vy *= 0.98;
    }

    // Keep puck inside rink
    if (this.x - this.radius < 0) { this.x = this.radius; this.vx *= -0.5; }
    if (this.x + this.radius > canvas.width) { this.x = canvas.width - this.radius; this.vx *= -0.5; }
    if (this.y - this.radius < 0) { this.y = this.radius; this.vy *= -0.5; }
    if (this.y + this.radius > canvas.height) { this.y = canvas.height - this.radius; this.vy *= -0.5; }
  }
}

function drawRink() {
  // Center red line
  ctx.strokeStyle = "red"; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(canvas.width/2,0); ctx.lineTo(canvas.width/2,canvas.height); ctx.stroke();

  // Blue lines
  ctx.strokeStyle = "blue";
  ctx.beginPath(); ctx.moveTo(canvas.width/3,0); ctx.lineTo(canvas.width/3,canvas.height); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(2*canvas.width/3,0); ctx.lineTo(2*canvas.width/3,canvas.height); ctx.stroke();

  // Center circle
  ctx.beginPath();
  ctx.arc(canvas.width/2,canvas.height/2,40,0,Math.PI*2);
  ctx.stroke();
}

let netLeft = {x:0,y:150,width:10,height:100};
let netRight = {x:790,y:150,width:10,height:100};

let team1 = [
  new Player(100,200,"red",false,false,"red"), // user
  new Player(80,150,"red",true,false,"red"),
  new Player(80,250,"red",true,false,"red"),
  new Player(50,200,"red",true,true,"red")
];
let team2 = [
  new Player(700,150,"blue",true,false,"blue"),
  new Player(700,250,"blue",true,false,"blue"),
  new Player(750,200,"blue",true,true,"blue")
];
let currentPlayer = team1[0];
let puck = new Puck(400,200);

function drawGoals() {
  ctx.fillStyle="gray";
  ctx.fillRect(netLeft.x,netLeft.y,netLeft.width,netLeft.height);
  ctx.fillRect(netRight.x,netRight.y,netRight.width,netRight.height);
}

function drawScore() {
  ctx.fillStyle="black";
  ctx.font="20px Arial";
  ctx.fillText(`Red: ${score.red} - Blue: ${score.blue}`, 340,20);
}

function checkGoal() {
  if (puck.x - puck.radius <= netLeft.x + netLeft.width &&
      puck.y > netLeft.y && puck.y < netLeft.y+netLeft.height) {
    score.blue++;
    reset();
  }
  if (puck.x + puck.radius >= netRight.x &&
      puck.y > netRight.y && puck.y < netRight.y+netRight.height) {
    score.red++;
    reset();
  }
}

function reset() {
  puck.x=400; puck.y=200;
  puck.vx=0; puck.vy=0;
  puck.carriedBy=null;
}

function movePlayer(player) {
  if (keys["ArrowUp"]) player.y -= player.speed;
  if (keys["ArrowDown"]) player.y += player.speed;
  if (keys["ArrowLeft"]) player.x -= player.speed;
  if (keys["ArrowRight"]) player.x += player.speed;

  // Stay inside rink
  player.x = Math.max(player.radius, Math.min(canvas.width-player.radius, player.x));
  player.y = Math.max(player.radius, Math.min(canvas.height-player.radius, player.y));

  // Shoot (only if not in crease)
  if (keys["Space"] && puck.carriedBy===player) player.shoot();

  // Pass
  if (keys["ShiftLeft"] && puck.carriedBy===player) {
    let teammate = team1.find(p=>p!==player && !p.isGoalie);
    if (teammate) {
      puck.carriedBy=null;
      let dx=teammate.x-player.x, dy=teammate.y-player.y;
      let dist=Math.sqrt(dx*dx+dy*dy);
      puck.vx=dx/dist*5; puck.vy=dy/dist*5;
    }
  }
}

function update() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawRink();
  drawGoals();
  drawScore();

  // --- Make teammates follow the rush ---
  if (puck.carriedBy === currentPlayer && currentPlayer.team === "red") {
    team1.forEach(p=>{
      if (p.isAI && !p.isGoalie) {
        p.x += (currentPlayer.x + 60 - p.x) * 0.02; 
        p.y += (currentPlayer.y + (Math.random()*60-30) - p.y) * 0.02; 
      }
    });
  }

  team1.forEach(p=>{ if(p.isAI) p.moveAI(); p.draw(); });
  team2.forEach(p=>{ if(p.isAI) p.moveAI(); p.draw(); });
  movePlayer(currentPlayer);

  puck.update(); puck.draw();

  // Puck pickup
  [...team1,...team2].forEach(p=>{
    let dx=p.x-puck.x, dy=p.y-puck.y;
    let dist=Math.sqrt(dx*dx+dy*dy);
    if (dist < p.radius+puck.radius && !puck.carriedBy) puck.carriedBy=p;
  });

  checkGoal();
  requestAnimationFrame(update);
}
update();
</script>
</body>
</html>

 
      
    
